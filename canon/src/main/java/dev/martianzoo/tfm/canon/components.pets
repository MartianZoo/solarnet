// These files contain definitions of classes. Not all of them will be defined during any actual
// game; that depends on how the game was configured. However, if a class is defined then it forces
// every other class its definition refers to to be defined as well (with the possible exception of
// effect *triggers*, since we can reason tht those triggers would simply never happen anyway.

// This file has game stuff that isn't player-specific. See player.pets for the rest.

ABSTRACT CLASS Component {                             // the single root of the whole hierarchy
  DEFAULT +Component!
  DEFAULT -Component!
}

ABSTRACT CLASS System {
  CLASS Class<Component> { HAS =1 This }               // magic rule: only a single name can go
                                                       // inside the <>; the `Class<Foo>` type is
                                                       // abstract iff the Foo class is abstract
  ABSTRACT CLASS Temporary {
    ABSTRACT CLASS Signal {                            // you'll never observe it existing, but
      This:: -This!                                    // things can still be triggered by it

      CLASS Ok                                         // magic rule: this should not be allowed to
                                                       // trigger anything
      CLASS Die { HAS MAX 0 This }                     // impossible to create, which is the point
    }
  }

  CLASS Engine {                                       // this is the very first component created,
    HAS MAX 1 This                                     // and kicks everything else off
    // This:: @createSingletons(This)
    This:: CorporationPhase                            // TODO SetupPhase

    PlayTag<Class<BuildingTag>>:: Accept<Class<Steel>>
    PlayTag<Class<SpaceTag>>:: Accept<Class<Titanium>>

    Pay<Class<Steel>>:: 2 Pay<Class<Megacredit>>
    Pay<Class<Titanium>>:: 3 Pay<Class<Megacredit>>    // should be innocuous for TradeAction...
  }
}

ABSTRACT CLASS Atomized                                // magic rule: see `Transformers.atomizer()`

// GLOBAL PARAMETERS ----------------------------------

ABSTRACT CLASS GlobalParameter[GP] : Atomized {
  DEFAULT +GlobalParameter.                            // by default gains/removes are "if possible"
  DEFAULT -GlobalParameter.

  This: TerraformRating                                // transformed to `This BY Owner: TR<Owner>`

  CLASS TemperatureStep[TEMP] {
    HAS MAX 19 This
    This IF =3 This: PROD[Heat]
    This IF =5 This: PROD[Heat]
    This IF =15 This: OceanTile
  }

  CLASS OxygenStep[O2] {
    HAS MAX 14 This
    This IF =8 This: TemperatureStep
  }

  CLASS VenusStep[VEN] {
    HAS MAX 15 This
    This IF =4 This: ProjectCard
    This IF =8 This: TerraformRating
  }

  CLASS OceanTile[OT] : Tile<MarsArea> {
    HAS MAX 9 OceanTile                                // `HAS MAX 9 This` wouldn't work!
    DEFAULT +OceanTile<WaterArea>
                                                       // We could almost count all adjacencies,
    ForwardAdjacency<This, Tile>: 2                    // but then the tile would trigger itself
  }
}


// MAPS AND TILES -------------------------------------

ABSTRACT CLASS MarsMap {                               // Hellas etc. are loaded from `maps.json5`
  HAS =1 This
  // This:: @createAll(This, Border)
}

ABSTRACT CLASS Area {
  HAS =1 This
  HAS MAX 1 Tile<This>                                 // circular reference is un-ideal, but...

  ABSTRACT CLASS MarsArea[MA] {                        // specific areas loaded from `maps.json5`
    Tile<This>:: @createAdjacencies(This)

    ABSTRACT CLASS LandArea[LA] {
      ABSTRACT CLASS VolcanicArea[VA]
    }
    ABSTRACT CLASS WaterArea[WA]
    ABSTRACT CLASS NoctisArea[NA]
  }
  ABSTRACT CLASS RemoteArea[RA]
}

ABSTRACT CLASS Tile<Area> { HAS MAX 1 This }

CLASS Neighbor<Tile<MarsArea>, MarsArea> [NBR] : System

ABSTRACT CLASS Adjacency<Tile, Tile> [ADJ] : System {
  This:: @forceLoad(Class<BackwardAdjacency>)

  CLASS ForwardAdjacency, BackwardAdjacency
}


// WORKFLOW-ISH ---------------------------------------

ABSTRACT CLASS HasActions {                            // specific actions come from `actions.json5`
  ABSTRACT CLASS StandardAction { HAS =1 This }
  ABSTRACT CLASS StandardProject { HAS =1 This }
}

CLASS Generation[GEN] { HAS 1 This }

ABSTRACT CLASS Generational {                          // things that disappear between gens
  Generation:: -This.                                  // <-- and look, there they go
}

CLASS Turn : Signal                                    // ha. turn signal. TODO should be owned

ABSTRACT CLASS Phase : System {
  // HAS MAX 1 Phase
  // Phase FROM This

  // CLASS SetupPhase
  CLASS CorporationPhase {
    Turn: CorporationCard, CardFront, 10 BuyCard?
    ActionPhase:: -This!
  }

  CLASS PreludePhase {                                 // TODO how to make it part of `P` bundle?
    This:: -CorporationPhase.
    Turn: PreludeCard, CardFront OR (-PreludeCard THEN 15) // should be ELSE (#22)
    ActionPhase:: -This!
  }

  CLASS ActionPhase {
    This:: -ResearchPhase.
    Turn: UseAction<StandardAction>?
  }

  CLASS ProductionPhase { This:: -ActionPhase, ResearchPhase FROM This }
  CLASS ResearchPhase { This:: Generation }
  CLASS End
}

// Player-specific components are in `player.pets`
