// Root of the hierarchy; everything with no other supertypes has this supertype
abstract class Component {
    count 0..*

    default Component!
    default -Component!
}

abstract class System
abstract class This : System // no subtypes, so you can never actually create a literal `This`

abstract class Ephemeral : System { // removes itself immediately - will never observe it existing
    count 0..0 // cardinalities can probably only be enforced after :: triggers are done

    This:: -This
}

class Ok : Ephemeral // when you need to do nothing

abstract class Barrier { // player must clean up themselves, by end of action
    This: (MAX 0 Barrier: Ok) // puts a task on the queue that can only be handled if 0 barriers left
}

class Die : System { // anything that tries to create this will stall
    count 0..0
}

class Generation

abstract class Generational { // things that disappear when the generation changes over
    Generation:: -This
}

abstract class Phase : System {
    count 0..1 // insufficient

    This IF 2 Phase:: Die    // forced to do "ThisPhase FROM Phase" // ack, no spec
    -This IF MAX 0 Phase:: Die  // cycles

    // There will be a heck of a lot more
    class ProductionPhase
    class End
}

abstract class Anyone { // : Owned<Anyone> !?
    // minimum of 1 means the engine will create an instance automatically - so,
    // in a 2-player game no Player3 class should even be defined.
    count 1..1

    class Npc : System

    abstract class Player {
        This:: 14 TerraformRating // not supporting multiplayer for a while yet
        This:: PROD[5]            // an ugly wart
        ProductionPhase: -5       // same ugly wart

        class Me
        // concrete players to be created dynamically
    }
}

abstract class GlobalParameter { // TODO splittable...
    default GlobalParameter.
    default -GlobalParameter.

    This: TerraformRating

    class TemperatureStep { count 0..19 }
    class OxygenStep      { count 0..14 }
    class VenusStep       { count 0..15 }
}

class TrackBonuser {
    count 1..1

    NOW 3 TemperatureStep: PROD[Heat]
    NOW 5 TemperatureStep: PROD[Heat]
    NOW 15 TemperatureStep: OceanTile

    NOW 8 OxygenStep: TemperatureStep

    NOW 4 VenusStep: ProjectCard
    NOW 8 VenusStep: TerraformRating
}

abstract class Area {
    count 1..1

    // Tile<This>:: (=1 Tile<This>: Ok) // prevent 2 tiles same area. TODO cycle

    abstract class RemoteArea
    abstract class MarsArea {
        abstract class LandArea {
            abstract class VolcanicArea
        }
        abstract class WaterArea
        abstract class NoctisArea
    }
}

abstract class Tile<Area> {
    count 0..1 // insufficient; see Area effect

    // This:: $createAdjacencies(This)

    class OceanTile : GlobalParameter {
        // count 0..9 wouldn't actually work

        default OceanTile<WaterArea>

        This:: (MAX 9 OceanTile: Ok)
        Adjacency<This, Tile>: 2
    }
}

// Have to be created the hard way...
class AreaAdjacency<MarsArea, MarsArea>  : System { count 0..1 }
class Neighbor<MarsArea, Tile>(HAS Tile) : System { count 0..1 }
class Adjacency<Tile, Tile>(HAS 2 Tile)  : System { count 0..1 }

abstract class Owned<Anyone> {
    // default *Owned<Me>

    class Required<Component> : Barrier

    class Purchase<Component> : Ephemeral {
        This: (MAX 0 Barrier: Component) //  TODO don't trigger for PlayCard
    }

    abstract class Resource {
        abstract class StandardResource {
            class Megacredit
            class Steel // Purchase<BuildingTag>:: Accept<This> - cycle
            class Titanium // Purchase<SpaceTag>:: Accept<This>
            class Plant
            class Heat
            class Energy { ProductionPhase:: Heat FROM This }
        }
    }

    class Production<StandardResource> { // TODO ensure owner == owner?
        ProductionPhase: StandardResource
    }

    class Owed<Resource> : Barrier {
       default -Owed.
       This:: Accept<Resource>
    }

    class Pay<Resource> : Ephemeral { // TODO lets you overpay like mad
        This:: -Owed<Resource>.
    }

    class Accept<Resource> : System {
        count 0..1
        default Accept.

        -Resource:: Pay<Resource>
        -Owed IF MAX 0 Owed:: -This // NOW MAX 0 Owed
    }

    class TerraformRating : Owned<Player> {
        ProductionPhase: 1
        End: VictoryPoint
    }

    // For "follow mode"
    abstract class CardBack { class CorporationCard, PreludeCard, ProjectCard }

    abstract class OwnedTile : Tile {
        class GreeneryTile : OwnedTile<MarsArea> {
            default GreeneryTile<LandArea(HAS Neighbor<OwnedTile>)>

            This: OxygenStep
            End: VictoryPoint
        }
        class CityTile {
            default CityTile<LandArea(HAS MAX 0 Neighbor<CityTile<Anyone>>)>

            End: VictoryPoint / Adjacency(HAS This, GreeneryTile<Anyone>)
        }
        class SpecialTile : OwnedTile<MarsArea> {
            default SpecialTile<LandArea>
        }
    }

    abstract class CardFront { // <CardResource> {  TODO circular
        count 0..1

        abstract class EventCard {
            This: PlayedEvent FROM This // shouldn't really be able to do this early
        }
        abstract class AutomatedCard
        abstract class ActiveCard

        // Remember, corps and preludes have none of those types
    }

    class PlayedEvent

    abstract class Cardbound<CardFront> {
        This:: (CardFront: Ok) // the card must actually be in play
        -CardFront:: -This     // becoming a PlayedEvent removes the tags

        abstract class Tag {
            // Purchase<CardFront>:: Purchase<This>     // VERY IFFY
            // CardFront:: This                         // VERY IFFY

            class BuildingTag, SpaceTag, CityTag, PowerTag, ScienceTag
            abstract class BioTag    { class PlantTag, MicrobeTag, AnimalTag }
            abstract class PlanetTag { class EarthTag, JovianTag, VenusTag }
        }

        abstract class CardResource : Resource { // , Cardbound<CardFront<CardResource>> { TODO
            -CardFront:: Die // gotta remove the resources first
            default CardResource.

            class Animal, Asteroid, Floater, Microbe, Science

            class NoResource : Die // so that non-holding cards have a type
        }

        class ActionUsed : Generational {
            count 0..1
        }
    }

    abstract class UseAction : Ephemeral {
        class UseAction1, UseAction2, UseAction3, UseAction4
    }

    class PlayCard<CardBack> : Purchase<CardFront> {
//      This:: CardBack: $handleRequirement(CardFront), Owed<Megacredit> / $costOf(CardFront)
        This: (MAX 0 Barrier: CardFront FROM CardBack)
    }
}

abstract class StandardAction {
    count 1..1

    class PlayCardFromHand   { -> PlayCard<CardFront> }
    class UseStandardProject { -> UseAction<StandardProject> }
    class UseCardAction      { -> UseAction<CardFront> THEN ActionUsed<CardFront> } // TODO weird
    class ConvertPlants      { 8 Plant -> GreeneryTile }
    class ConvertHeat        { 8 Heat -> TemperatureStep }

    // Technically a standard project, but that makes things harder
    class SellPatents        { 1 ProjectCard -> 1 } // TODO X
}

abstract class StandardProject {
    count 1..1

    class PowerPlant   { 11 -> PROD[Energy] }
    class AsteroidSP   { 14 -> TemperatureStep }
    class AirScrapping { 15 -> VenusStep }
    class BufferGas    { 16 -> TerraformRating }
    class Aquifer      { 18 -> OceanTile }
    class Greenery     { 23 -> GreeneryTile }
    class City         { 25 -> CityTile, PROD[1] }
}

abstract class NextCardEffect : Generational, System {
    count 0..1

    CardFront:: -This
}
