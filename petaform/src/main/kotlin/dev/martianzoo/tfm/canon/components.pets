class Generation {
    count 1..*
}

abstract class Generational {                          // things that disappear when the generation changes over
    Generation:: -This                                 // and look, there they go (TODO ProductionPhase?)
}

abstract class Player : Anyone {
    This:: 20 TerraformRating

    This:: PROD[5]                                     // No negative Components! So we need a hack; at least this one
    ProductionPhase: -5                                // confines the damage to Specialist/Generalist (and Robinson but it
                                                       // needs custom code anyway).
                                                       // `Instr / PROD[1]` must be banned! But no great loss.
    class SoloPlayer

    abstract class Me
}

abstract class GlobalParameter {                       // TODO splittable...
    default GlobalParameter.                           // By default, gains are "if possible"

    This: TerraformRating

    class TemperatureStep { count 0..19 }
    class OxygenStep      { count 0..14 }
    class VenusStep       { count 0..15 }
}

class TrackBonuser {
    count 1..1

    NOW 3 TemperatureStep: PROD[Heat]                  // `NOW <predicate>` fires whenever that predicate transitions
    NOW 5 TemperatureStep: PROD[Heat]                  // from false to true
    NOW 15 TemperatureStep: OceanTile

    NOW 8 OxygenStep: TemperatureStep

    NOW 4 VenusStep: ProjectCard
    NOW 8 VenusStep: TerraformRating

    NOW 10 OceanTile:: Die                             // Putting count 0..9 on OceanTile doesn't work!
}

abstract class Area {
    count 1..1

    NOW 2 Tile<This>:: Die                             // The engine will never let a Die exist, so this prevents 2 tiles
                                                       // (TODO 2 Occupants) from ever using the same Area
    abstract class RemoteArea
    abstract class MarsArea {
        abstract class LandArea {
            abstract class VolcanicArea
        }
        abstract class WaterArea
        abstract class NoctisArea
    }
}

abstract class Tile<Area> {
    count 0..1                                         // insufficient; see Area effect

    class OceanTile : GlobalParameter {
        default OceanTile<WaterArea>

        Adjacency<This, Tile>: 2
    }
}

class AreaAdjacency<MarsArea, MarsArea> {              // TODO figure this shit out
    count 0..1
}
class Neighbor<MarsArea, Tile>(HAS Tile) {
    count 0..1
}
class Adjacency<Tile, Tile>(HAS 2 Tile) {
    count 0..1
}

abstract class Owned<Anyone> {                         // TODO default *Owned<Me>??
    class VictoryPoint

    abstract class Resource {
        abstract class StandardResource {
            class Megacredit
            class Steel
            class Titanium
            class Plant
            class Heat
            class Energy {
                ProductionPhase:: Heat FROM This       // :: ensures it happens before production
            }
        }
    }

    class Production<StandardResource> {
        ProductionPhase: StandardResource              // Specializing to Production<Heat> specializes this too
    }

    class TerraformRating : Owned<Player> {            // TODO what else should be <Player> and why
        ProductionPhase: 1
        End: VictoryPoint
    }

    abstract class CardBack {                          // For "follow mode" only
        class CorporationCard, PreludeCard, ProjectCard
    }

    abstract class OwnedTile : Tile {
        class GreeneryTile : Tile<MarsArea> {
            default GreeneryTile<LandArea(HAS Neighbor<OwnedTile>)>

            This: OxygenStep
            End: VictoryPoint
        }
        class CityTile {                               // TODO "open" to allow Capital to subclass it
            default CityTile<LandArea(HAS MAX 0 Neighbor<CityTile<Anyone>>)>

            End: VictoryPoint / Adjacency(HAS This, GreeneryTile<Anyone>)
        }
        class SpecialTile : OwnedTile<MarsArea> {      // TODO "open"
            default SpecialTile<LandArea>
        }
    }

    abstract class Milestone {
        count 0..1

        NOW 4 Milestone<Anyone>: Die
    }

    abstract class CardFront {                         // <CardResource>  TODO circular
        count 0..1

        abstract class EventCard {
            This: PlayedEvent FROM This                // problem: how to still get the VPs??
        }                                              // could we get this happen autom. at EOT?
        abstract class AutomatedCard
        abstract class ActiveCard
    }

    class PlayedEvent

    abstract class Cardbound<CardFront> {
        This:: (CardFront: Ok)                         // i.e., the card must actually be in play
        -CardFront:: -This                             // on becoming a PlayedEvent

        abstract class Tag {
         // Purchase<CardFront>:: Purchase<This>       // VERY VERY IFFY
         // CardFront:: This                           // VERY VERY IFFY

            class BuildingTag, SpaceTag
            class CityTag, PowerTag, ScienceTag

            abstract class BioTag {
                class PlantTag, MicrobeTag, AnimalTag
            }
            abstract class PlanetTag {
                class EarthTag, JovianTag, VenusTag
            }
        }

        abstract class CardResource : Resource {       // , Cardbound<CardFront<CardResource>> { TODO
            -CardFront:: Die                           // gotta remove the resources first
            default CardResource.

            class Animal, Microbe, Science
            class Floater, Asteroid

            class NoResource : Die                     // Because all cards must have a resource type
        }

        class ActionUsed : Generational {
            count 0..1
        }
    }

    class TagType                                      // No idea yet how this will actually work

    abstract class UseAction : Ephemeral {
        class UseAction1, UseAction2, UseAction3, UseAction4
    }

    class PlayCard<CardBack> {   // not open ... extend Purchase???
//      This:: CardBack: $handleRequirement(CardFront), Owed<Megacredit> / $costOf(CardFront)
        This: (MAX 0 Barrier: CardFront FROM CardBack)
    }
}

abstract class StandardAction {
    count 1..1

    class PlayCardFromHand   { -> PlayCard<CardFront> }
    class UseStandardProject { -> UseAction<StandardProject> }
    class UseCardAction      { -> UseAction<CardFront> THEN ActionUsed<CardFront> }
    class ConvertPlants      { 8 Plant -> GreeneryTile }
    class ConvertHeat        { 8 Heat -> TemperatureStep }
    class ClaimMilestone     { 8 -> Milestone }

    // TODO Award

    class SellPatents        { 1 ProjectCard -> 1 }    // Technically a standard project, but that makes things hard
                                                       // TODO X
}

abstract class StandardProject {
    count 1..1

    class PowerPlant   { 11 -> PROD[Energy] }
    class AsteroidSP   { 14 -> TemperatureStep }
    class AirScrapping { 15 -> VenusStep }
    class Aquifer      { 18 -> OceanTile }
    class Greenery     { 23 -> GreeneryTile }
    class City         { 25 -> CityTile, PROD[1] }

    class BufferGas {                                  // TODO figure out the right way to make this not exist in non-TRsolo games
        count 0..1
        16 -> TerraformRating
    }
}

abstract class NextCardEffect : Generational {
    count 0..1

    CardFront:: -This
}

abstract class Phase {
    count 0..1                                         // insufficient, see next

    NOW 2 Phase OR MAX 0 Phase:: Die                   // Once any Phase exists there must always be exactly one. The
                                                       // new one can't remove the old one itself. This here forces
                                                       // phase changes to be like `WhateverPhase FROM Phase`
                                                       // TODO such a roundabout way to say it

                                                       // `This:: -Phase.` wouldn't know not to remove itself, and would
                                                       // let a strange phase with `-This:: Die` stick around. We'd need
                                                       // `This:: -(Phase !This).` or `PRE This: -Phase.` or a new
                                                       // directive like `This FROM Phase.` but all this is gross.
    class SetupPhase
    class CorporationPhase
    class PreludePhase                                 // TODO how to skip it when not using Prelude
    class ResearchPhase
    class ActionPhase
    class ProductionPhase
    class SolarPhase
    class End
}
