// This file has player-specific game stuff

// PLAYERS -------------------------------------------------

abstract class Anyone {
    HAS =1 This

    abstract class Player : Anyone {
        This: 20 TerraformRating<This>

        // Hack!                                            // We're forced to use some ugly hack; at least this one
        This: PROD[5]                                       // confines the damage to Specialist/Generalist/Robinson and
        ProductionPhase: -5                                 // presentation issues. All the alternatives look worse.
                                                            // This makes `/ PROD[1]` extremely dodgy, almost worth
                                                            // banning... except it does still work fine for Banker.

        PlayTag<BuildingTag>:: Accept<Steel>                // becomes `Pay<S> BY Player:: 2 Pay<MC, Player>` (but how?)
        Pay<Steel>:: 2 Pay<Megacredit>                      // TODO where do these really belong??

        PlayTag<SpaceTag>:: Accept<Titanium>
        Pay<Titanium>:: 3 Pay<Megacredit>                   // should be innocuous for TradeAction?

        class Player1, Player2, Player3, Player4, Player5   // in PETS, nesting = subtyping
    }
    class Npc                                               // this is who does WGT, etc
}


// PLAYER PROPERTY / GENERAL -------------------------------

abstract class Owned<Anyone> {
    default This<Player>                                    // affects ALL references to owned cpts that don't specify
                                                            // an owner -- the only default of this kind we need

    abstract class Outcome {                                // the only 100% useless component type
        class Winner, Place2, Place3, Place4, Place5
    }

    class VictoryPoint

    class TerraformRating {
        ProductionPhase: 1
        End: VictoryPoint
    }

    class StartToken { HAS MAX 1 StartToken }

    abstract class Milestone                                // The rest of the stuff in this file is also Owned, just
}                                                           // explicitly instead of by nesting


// TILES ---------------------------------------------------

abstract class OwnedTile : Owned, Tile {
    class GreeneryTile : Tile<MarsArea> {
        // TODO this needs to use `HAS?` or something
        default +This<LandArea(HAS Neighbor<OwnedTile>)>
        This: OxygenStep
        End: VictoryPoint
    }

    class CityTile {
        default +This<LandArea(HAS MAX 0 Neighbor<CityTile<Anyone>>)>           // TODO line-wrapping
        End: VictoryPoint / Adjacency(HAS This, GreeneryTile<Anyone>)
    }

    abstract class SpecialTile : Tile<MarsArea> {
        default +This<LandArea>
    }
}


// RESOURCES -----------------------------------------------

abstract class Resource : Owned {
    abstract class StandardResource {
        abstract class Default                              // Things like `Foo: 5` become `Foo: Default`
        class Megacredit : Default

        class Steel, Titanium, Plant, Heat

        class Energy { ProductionPhase:: Heat FROM This }
    }

    abstract class CardResource : Cardbound<Holder> {       // TODO Cardbound<Holder<CardResource>>, forcing match
        default +This.

        // All others are card-specific; see cards.json5
        class Animal, Microbe, Science, Floater, Asteroid
    }
}

class Production<CLASS StandardResource> : Owned {
    ProductionPhase: StandardResource                       // TODO subtype specialization
}

abstract class Holder<CLASS CardResource> : CardFront


// CARDS ---------------------------------------------------

abstract class CardBack : Owned {
    class CorporationCard                                   // once a card is played and becomes a CardFront, nothing in
    class PreludeCard                                       // the game ever cares what kind of CardBack it used to be..
    class ProjectCard                                       // well that used to be true until "Double Down" in Dec 2022
}

abstract class CardFront : Owned {
    abstract class EventCard {
        This: PlayedEvent FROM This                         // problem: how to still get the VPs??
    }                                                       // could we get this happen autom. at EOT?
    abstract class AutomatedCard
    abstract class ActiveCard                               // these types can all be mixed; what prevents bogus combos?

    abstract class ActionCard : HasActions
}

class PlayedEvent : Owned

abstract class Cardbound<CardFront<Anyone>>:Owned<Anyone> { // TODO require the two `Anyone`s to match, but only
    abstract class Tag {                                    // because both were stated explicitly (not for Neighbor)
        class BuildingTag, SpaceTag
        class CityTag, PowerTag, ScienceTag

        abstract class BioTag {                             // not really a game defined thing, but convenient
            class PlantTag, MicrobeTag, AnimalTag
        }
        abstract class PlanetTag {
            class EarthTag, JovianTag, VenusTag
        }
    }

    class Cost                                              // as part of creating Card001<P4>, make 8 Cost<Card001<P4>>
}                                                           // does this really need to be `Owned`?


// ACTIONS -------------------------------------------------

abstract class UseAction<HasActions> : Owned, Signal {      // TODO How to make owner same, when HasActions has both
    class UseAction1, UseAction2, UseAction3                // owned and unowned subclasses?
    class UseAction4, UseAction5, UseAction6                // it's enough to handle Utopia etc the hard way
}

// TODO still consider inverting this?
class ActionUsedMarker : Cardbound<ActionCard>, Generational {
    HAS MAX 1 This
}


// PAYMENT MECHANICS ---------------------------------------

abstract class PaymentMechanic : Owned, Temporary {
    abstract class Barrier {                                // player must clean up themselves, by end of action
        This: (MAX 0 This: Ok)                              // adds a task that can only be handled if 0 barriers left
    }

    class Owed<CLASS Resource> : Barrier {                  // created when payment due, removed by discount cards/
       This:: Accept<Resource>
    }

    class Accept<CLASS Resource> {                          // Created in response to PlayTag or the actions on 4
        HAS MAX 1 This                                      // special cards. (extend Temporary?)
        default +This.
    }

    class Pay<CLASS Resource> : Signal {                    // player uses it like `8 Pay<Heat> FROM Heat`
        This:: -Owed<Resource>.                             // But also cards can pay in response to signals
    }

    class BuyCard : Signal                                  // used by ResearchPhase, InvGuild, BusNet
                                                            // triggers Polyphemos, Terralabs

    class PlayTag<CLASS Tag> : Signal                       // triggers Accept<Steel/Dirig/etc> and tag-based discounts

                                                            // used by PlayCardFromHand, ValTrust, EcoEx, ExSponsor,
    class PlayCard<CLASS CardBack, CLASS CardFront> {       // NewPartner, Merger; triggers EarthCat etc.
        This:: $handleRequirement(CardFront)                // ?
        This: Owed<Megacredit> / Cost<CardFront>
        This: =0 Barrier: (CardFront FROM CardBack, -This)  // adds task to queue that must eventually be completed
    }
}
