// These files contain definitions of classes. Not all of them will be defined during any actual
// game; that depends on how the game was configured. However, if a class is defined then it forces
// every other class its definition refers to to be defined as well (with the possible exception of
// effect *triggers*, since we can reason tht those triggers would simply never happen anyway.

// This file has game stuff that isn't player-specific

// GLOBAL PARAMETERS ---------------------------------------

abstract class GlobalParameter {                            // TODO must be added 1-by-1 - how?
    default +This.                                          // by default, gains are "if possible"

    This: TerraformRating                                   // becomes `This BY Player: TR<This>`
                                                            // side effect: WGT doesn't trigger it
    class TemperatureStep {
        HAS MAX 19 This
        This: (=3 This: PROD[Heat]) OR Ok                   // gated instrs are still mandatory, so without the `OR Ok`
        This: (=5 This: PROD[Heat]) OR Ok                   // we would be at a dead end
        This: (=15 This: OceanTile) OR Ok
    }

    class OxygenStep {
        HAS MAX 14 This
        This: (=8 OxygenStep: TemperatureStep) OR Ok
    }

    class VenusStep {
        HAS MAX 15 This
        This: (=4 This: ProjectCard) OR Ok
        This: (=8 This: TerraformRating) OR Ok
    }

    class OceanTile : Tile<MarsArea> {
        HAS MAX 9 OceanTile
        default +This<WaterArea>
        ForwardAdjacency<This, Tile>: 2
    }
}


// MAPS AND TILES ------------------------------------------

abstract class MarsMap {
    This:: $createBorders(This)                             // save all :: effects until after all
                                                            // singletons are created...
    class Tharsis, Hellas, Elysium
}

abstract class Area(HAS MAX 1 Tile) {
    HAS =1 This                                             // singleton: if the *type* exists, the instance does too

    abstract class MarsArea {                               // TODO <MarsMap>?
        abstract class LandArea {
            abstract class VolcanicArea
        }
        abstract class WaterArea
        abstract class NoctisArea
    }

    abstract class RemoteArea(HAS MAX 0 Border)
}

abstract class Tile<Area>
                                                            // TODO figure out how to not need this
class Border<Area, MarsArea> {                              // early on will create 3-6 of these for each MarsArea
    HAS MAX 1 This                                          // listing that one first. So each border will actually
                                                            // be here twice, once in each direction
    Tile<Area>: Neighbor<Tile<Area>, MarsArea>              // TODO BRUTAL HACK BRUTAL HACK
}

class Neighbor<Tile, MarsArea> {
    HAS MAX 1 This
    Tile<MarsArea>:: ForwardAdjacency<Tile, Tile<MarsArea>>
    Tile<MarsArea>:: BackwardAdjacency<Tile<MarsArea>, Tile>
}

abstract class Adjacency<Tile, Tile> {
    HAS MAX 1 This
    class ForwardAdjacency, BackwardAdjacency
}

class Row<MarsArea>                                         // after creating Hellas_5_x then create 5 Row<Hellas_5_x>

// ACTIONS -------------------------------------------------

abstract class HasActions {

    abstract class StandardAction {
        HAS =1 This

        class PlayCardFromHand   { -> PlayCard<ProjectCard, CardFront> }
        class UseStandardProject { -> UseAction<StandardProject> }
        class UseActionFromCard  { -> UseAction<ActionCard> THEN ActionUsedMarker<ActionCard> }
        class ConvertPlants      { 8 Plant -> GreeneryTile }
        class ConvertHeat        { 8 Heat -> TemperatureStep }

        class SellPatents        { 1 ProjectCard -> 1 }     // Technically a standard project, but that makes Credicor
    }                                                       // and Std Tech annoying for no real benefit. TODO "X"

    abstract class StandardProject {
        HAS =1 This

        class PowerPlant   { 11 -> PROD[Energy] }
        class AsteroidSP   { 14 -> TemperatureStep }
        class AirScrapping { 15 -> VenusStep }
        class Aquifer      { 18 -> OceanTile }
        class Greenery     { 23 -> GreeneryTile }
        class City         { 25 -> CityTile, PROD[1] }
    }
}


// WORKFLOW ------------------------------------------------

class Generation { HAS 1 This }                             // we're always in at least gen 1

abstract class Generational {                               // things that disappear between gens
    Generation:: -This                                      // <-- and look, there they go
}

abstract class Phase {                                      // Phases should *do* as little as possible, and just be
    HAS MAX 1 Phase                                         // triggers for other component types

    class SetupPhase                                        // start of gameplay thru discarding
    class CorporationPhase                                  // each player plays corp & buys cards
    class PreludePhase                                      // each: play or discard prelude 2x
    class ResearchPhase { This:: Generation }               // skipped in gen1
    class ActionPhase                                       // continues until all have passed
    class ProductionPhase                                   // self-explanatory
    class SolarPhase                                        // maybe we don't need to split it up
    class ConvertPlantsPhase                                // each does X UseAction<ConvertPlants>
    class End                                               // triggers VP payouts
    class Shutdown                                          // assigns Outcomes then no more changes
}
