// class Game(HAS MAX 1 MarsMap, MAX 1 Phase, MAX 9 OceanTile)

// Root of the hierarchy; everything with no other supertypes has this supertype
abstract class Component {
    default Component! // all gains/removes are mandatory unless overridden
    default -Component!
}

abstract class Signal(HAS MAX 0 This) {                // removes itself immediately - will never observe it existing
    This:: -This                                       // but can be triggered by it
}

class Ok : Signal                                      // when you need to do nothing

abstract class Barrier {                               // player must clean up themselves, by end of action
    This: (MAX 0 Barrier: Ok)                          // weird. add a task that can only be handled if 0 barriers left
}

class Die(HAS MAX 0 This)

abstract class Anyone(HAS =1 This) {
    abstract class Player : Anyone {
        This:: 20 TerraformRating

        PlayTag<BuildingTag>:: Accept<Steel>           // These don't seem to belong anywhere
        PlayTag<SpaceTag>:: Accept<Titanium>

        This:: PROD[5]                                 // No negative Components! So we need a hack; at least this one
        ProductionPhase: -5                            // confines the damage to Specialist/Generalist (and Robinson,
    }                                                  // but it needs custom code anyway). Other hacks seem worse.
}                                                      // `Instr / PROD[1]` is very very dodgy but works for Banker.

class Player1 : Player
class Player2 : Player

abstract class Area(HAS =1 This, MAX 1 Tile) {
    abstract class RemoteArea
    abstract class MarsArea {
        abstract class LandArea {
            abstract class VolcanicArea
        }
        abstract class WaterArea
        abstract class NoctisArea
    }
}

abstract class Tile<Area>

abstract class MarsMap {
    This:: $createMarsAreas(This) THEN $createBorders(This)

    class Tharsis, Hellas, Elysium
}

// <MarsArea^1, MarsArea^2> ?
class Border<MarsArea, MarsArea>(HAS 2 MarsArea, MAX 1 This) {
    // These probably have to be created programmatically; e.g. on Border<Tharsis3_3, Tharsis3_4>
    // we have `Tile<Tharsis3_4>: Neighbor<Tile, Tharsis3_3>`
}

// <Tile<MarsArea^1>, MarsArea^2> ?
class Neighbor<Tile, MarsArea>(HAS Tile, MAX 1 This) {
    Tile<MarsArea>: Adjacency<Tile, Tile<MarsArea>> // SPEC
}

// <Tile^1, Tile^2> ?
class Adjacency<Tile, Tile>(HAS 2 Tile, MAX 1 This)

abstract class GlobalParameter {                       // TODO splittable...
    default GlobalParameter.                           // By default, gains are "if possible"

    This: TerraformRating

    class TemperatureStep(HAS MAX 19 This)
    class OxygenStep(HAS MAX 14 This)
    class VenusStep(HAS MAX 15 This)

    class OceanTile : Tile<MarsArea> {
        default OceanTile<WaterArea>

        Adjacency<This, Tile>: 2                       // TODO "BY Me"
    }
}

class TrackBonuser(HAS =1 This) {
    NOW 3 TemperatureStep: PROD[Heat]                  // `NOW <reqt>` fires whenever that reqt transitions
    NOW 5 TemperatureStep: PROD[Heat]                  // from unmet to met
    NOW 15 TemperatureStep: OceanTile

    NOW 8 OxygenStep: TemperatureStep

    NOW 4 VenusStep: ProjectCard
    NOW 8 VenusStep: TerraformRating

    NOW 10 OceanTile:: Die                             // OceanTile(HAS MAX 9 This) won't work
}

class Generation

abstract class Generational {                          // things that disappear when the generation changes over
    Generation:: -This                                 // and look, there they go
}

abstract class Owned<Anyone> {                         // TODO default *Owned<Me>??
    class VictoryPoint

    abstract class Resource {
        abstract class StandardResource {
            class Megacredit, Steel, Titanium, Plant, Heat
            class Energy { ProductionPhase:: Heat FROM This }
        }
    }

    class Production<StandardResource> {
        ProductionPhase: StandardResource              // Specializing to Production<Heat> specializes this too
    }

    class TerraformRating : Owned<Player> {
        ProductionPhase: 1
        End: VictoryPoint
    }

    abstract class CardBack {                          // For "follow mode" only
        class CorporationCard, PreludeCard, ProjectCard
    }

    abstract class OwnedTile : Tile {
        class GreeneryTile : Tile<MarsArea> {
            default GreeneryTile<LandArea(HAS Neighbor<OwnedTile>)> // TODO - yikes
            This: OxygenStep
            End: VictoryPoint
        }
        class CityTile {
            default CityTile<LandArea(HAS MAX 0 Neighbor<CityTile<Anyone>>)>
            End: VictoryPoint / Adjacency(HAS This, GreeneryTile<Anyone>)
        }
        abstract class SpecialTile : OwnedTile<MarsArea> {
            default SpecialTile<LandArea>
        }
    }

    abstract class Milestone                           // not really doing anything with this yet

    abstract class CardFront {                         // TODO <CardResource> { // TODO <This> ?
        abstract class EventCard {
            This: PlayedEvent FROM This                // problem: how to still get the VPs??
        }                                              // could we get this happen autom. at EOT?
        abstract class AutomatedCard
        abstract class ActiveCard : ActionHaver        // TODO maybe only have actual action cards do that
    }

    class PlayedEvent

    abstract class Cardbound<CardFront>(HAS CardFront) {
        -CardFront:: -This                             // on becoming a PlayedEvent

        abstract class CardResource : Resource {       // , Cardbound<CardFront<This>> ?
            -CardFront:: Die                           // gotta remove the resources first
            default CardResource.

            class Animal, Microbe, Science
            class Floater, Asteroid

            class NoResource { This:: Die }            // Because all cards must have a resource type
        }

        // TODO .. but.. these have to exist as soon as the card does, for triggers....
        abstract class Tag {
            class BuildingTag, SpaceTag
            class CityTag, PowerTag, ScienceTag

            abstract class BioTag {
                class PlantTag, MicrobeTag, AnimalTag
            }
            abstract class PlanetTag {
                class EarthTag, JovianTag, VenusTag
            }
        }

        class ActionUsed(HAS MAX 1 This) : Generational
    }

    abstract class UseAction<ActionHaver> : Signal {
        class UseAction1, UseAction2, UseAction3, UseAction4
    }

    class Owed<Resource> : Barrier {
       default -Owed.
       This:: Accept<Resource>
    }

    class Accept<Resource>(HAS MAX 1 This) {
        default Accept.                                // never hurts to accept twice

        -Resource:: Pay<Resource>                      // TODO this is not quite right?
        NOW MAX 0 Owed:: -This                         // TODO what if there never are/were any Oweds?
    }

    class Pay<Resource> : Signal {                     // TODO lets you overpay like mad
        This:: -Owed<Resource>
    }

    class BuyCard {
        NOW MAX 0 Barrier: ProjectCard FROM This
    }

    class PlayTag<Tag> : Signal

    class PlayCard<CardFront> {
        This:: $handleRequirement(CardFront), $handleCost(CardFront) // TODO Owed<Mc> / $costOf(CardFront)
        NOW MAX 0 Barrier: (CardFront FROM CardBack, -This)
    }
}

abstract class ActionHaver {

    abstract class StandardAction(HAS =1 This) {
        class PlayCardFromHand   { -> PlayCard<CardFront> }
        class UseStandardProject { -> UseAction<StandardProject> }
        class UseCardAction      { -> UseAction<CardFront> THEN ActionUsed<CardFront> }
        class ConvertPlants      { 8 Plant -> GreeneryTile }
        class ConvertHeat        { 8 Heat -> TemperatureStep }

        class SellPatents        { 1 ProjectCard -> 1 }// Technically a standard project, but that makes things hard
                                                       // TODO X
    }

    abstract class StandardProject(HAS =1 This) {
        class PowerPlant   { 11 -> PROD[Energy] }
        class AsteroidSP   { 14 -> TemperatureStep }
        class AirScrapping { 15 -> VenusStep }
        class Aquifer      { 18 -> OceanTile }
        class Greenery     { 23 -> GreeneryTile }
        class City         { 25 -> CityTile, PROD[1] }
    }
}

abstract class Phase {
    class SetupPhase
    class CorporationPhase
    class PreludePhase
    class ResearchPhase
    class ActionPhase
    class ProductionPhase
    class SolarPhase
    class End
}
